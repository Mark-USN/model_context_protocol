# model_context_protocol.py
# 20251010 MMH A script to start/stop a detached MCP server or run a client.

import sys
import os
import shutil
import argparse
import asyncio
import subprocess
import signal
from pathlib import Path

# import modules.mcp_servers.demo_server as demo_server
import modules.mcp_clients as mcp_clients

# ---- Paths (PID & LOG live next to this file) ----
SCRIPT_DIR = Path(__file__).resolve().parents[1]
PID_FILE = SCRIPT_DIR / "model_context_protocol.pid"
LOG_FILE = SCRIPT_DIR / "model_context_protocol.log"

# ---- Helper to find pythonw.exe on Windows ----
# On Windows, we want to use pythonw.exe to avoid a console window popping up.
def _pythonw_exe():
    # Prefer side-by-side pythonw next to the current interpreter
    exe = sys.executable
    if exe.lower().endswith("python.exe"):
        candidate = exe[:-10] + "pythonw.exe"
        if os.path.exists(candidate):
            return candidate
    # Fallback to PATH
    return shutil.which("pythonw.exe") or exe  # last resort: python.exe


# ---- Background launcher (detached subprocess) ----
def start_server_detached(host: str, port: int):
    """
    Launch this script in a new console that runs the server in the foreground.
    Parent returns immediately; child keeps running and logs to LOG_FILE.
    """
    # This was generated by feeding the desired command line to shlex.split()  
    cmd = [_pythonw_exe(), '-m', 'mcp_servers.demo_server', '--host', host, '--port', str(port)]

    # Open the logfile for append; redirect child's stdout/stderr there
    log_fh = open(LOG_FILE, "a", buffering=1, encoding="utf-8", errors="replace")

    # Platform-specific detachment
    kwargs = {}
    if os.name == "nt":
        # Fully detach on Windows
        kwargs["creationflags"] = subprocess.DETACHED_PROCESS | subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW        # On Windows, close_fds cannot be True when redirecting std handles on py<3.12; omit it.
    else:
        # Detach from controlling terminal/session on POSIX
        kwargs["preexec_fn"] = os.setpgrp
        kwargs["close_fds"] = True

    proc = subprocess.Popen(
        cmd,
        stdout=log_fh,
        stderr=log_fh,
        stdin=subprocess.DEVNULL,
        cwd=str(SCRIPT_DIR),
        **kwargs
    )

    # Write the PID so we can stop later
    PID_FILE.write_text(str(proc.pid), encoding="utf-8")
    print(f"âœ… Server started (detached) on http://{host}:{port}")
    print(f"   PID: {proc.pid}")
    print(f"   Log: {LOG_FILE}")


def stop_server():
    """
    Stop a previously started detached server using the PID file.
    """
    if not PID_FILE.exists():
        print("No PID file found; server may not be running.")
        return

    try:
        pid = int(PID_FILE.read_text(encoding="utf-8").strip() or "0")
    except ValueError:
        print("PID file is corrupted.")
        return

    if pid <= 0:
        print("Invalid PID in PID file.")
        return

    # Try to terminate cross-platform
    try:
        if os.name == "nt":
            # Use taskkill to terminate the process tree reliably on Windows
            subprocess.run(["taskkill", "/PID", str(pid), "/T", "/F"],
                           capture_output=True, text=True)
        else:
            os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        print(f"Process {pid} not found.")
    except Exception as e:
        print(f"Error stopping process {pid}: {e}")
    else:
        print(f"ðŸ›‘ Sent stop signal to PID {pid}")

    # Clean up PID file regardless (best-effort)
    try:
        PID_FILE.unlink(missing_ok=True)
    except Exception:
        pass



def port_type(value: str) -> int:
    """Custom argparse type that validates a TCP port number."""
    try:
        port = int(value)
    except ValueError:
        raise argparse.ArgumentTypeError(f"Port must be an integer (got {value!r})")
    
    if not (1 <= port <= 65535):
        raise argparse.ArgumentTypeError(f"Port number must be between 1 and 65535 (got {port})")
    
    return port

def main():
    parser = argparse.ArgumentParser(
        description="Create and run an MCP server or client."
    )
    parser.add_argument("--mode",
        choices=["server", "client", "stop-server"],
        type=str.lower,
        required=True,
        help="Run as server, client, or stop-server."
    )
    parser.add_argument("--host", type=str, default="127.0.0.1",
                        help="Host name or IP address (default 127.0.0.1).")
    parser.add_argument("--port", type=port_type, default=8085,
                        help="TCP port to bind/connect (default 8085).")

    args = parser.parse_args()

    if args.mode == "server":
        # Parent: launch a detached child and return immediately
        start_server_detached(args.host, args.port)
        # Parent exits now; detached child continues running.

    elif args.mode == "stop-server":
        stop_server()

    elif args.mode == "client":
        client = mcp_clients.universal_client(args.host, args.port)
        asyncio.run(client.run())


if __name__ == "__main__":
    main()
