# model_context_protocol.py
# 20251010 MMH A script to start/stop a detached MCP server or run a client. 
#
# PSEUDOCODE / PLAN (detailed):
#  - Provide a small ICONS mapping that exposes common "charters" (emoji/icons) by name.
#    - Include common options: check marks, ballot box with check, red square, stop sign, cross mark, info.
#    - Document codepoints and short description in comments so a developer can pick one.
#  - Add a helper function get_icon(name, fallback="") to return the chosen icon.
#  - Replace hard-coded emoji strings in logger messages with calls to get_icon(...)
#  - Keep behavior unchanged otherwise; ensure PID-file missing logic does not reference undefined variables.
#  - Keep file readable and self-contained; don't introduce external dependencies.
#
# USAGE:
#  - Use get_icon("check"), get_icon("ballot"), get_icon("red_box"), get_icon("stop"), get_icon("cross"), get_icon("info")
#  - Or directly index ICONS["check"]
#
import sys
import os
import shutil
import argparse
import asyncio
import subprocess
import signal
import logging
from modules.utils.get_icons import get_icon
from pathlib import Path

from modules.mcp_servers import demo_server
from modules.mcp_clients import universal_client


logging.basicConfig(
    # level=logging.DEBUG if settings.debug else logging.INFO,
    level=logging.INFO,
    format="[%(asctime)s] %(levelname)-8s %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(Path(__file__).stem)


# ---- Paths (PID & LOG live next to this file) ----
SRC_DIR = Path(__file__).resolve().parent
ROOT_DIR = SRC_DIR.parent.resolve()
PID_FILE = ROOT_DIR / "mcp.pid"
LOG_FILE = ROOT_DIR / "mcp.log"


# ---- Helper to find pythonw.exe on Windows ----
# On Windows, we want to use pythonw.exe to avoid a console window popping up.
def _pythonw_exe():
    # Prefer side-by-side pythonw next to the current interpreter
    exe = sys.executable
    if exe.lower().endswith("python.exe"):
        candidate = exe[:-10] + "pythonw.exe"
        if os.path.exists(candidate):
            return candidate
    # Fallback to PATH
    return shutil.which("pythonw.exe") or exe  # last resort: python.exe


# ---- Background launcher (detached subprocess) ----
def start_server(host: str, port: int, debug: bool):

    if debug:
        # subprocess.run(cmd, cwd=str(SCRIPT_DIR))
        demo_server.launch_server(host, port)

    else:
        """
        Launch this script in a new console that runs the server in the foreground.
        Parent returns immediately; child keeps running and logs to LOG_FILE.
        """
        # This was generated by feeding the desired command line to shlex.split()  
        cmd = [_pythonw_exe(), '-m', 'modules.mcp_servers.demo_server', '--host', host, '--port', str(port)]

        # Open the logfile for append; redirect child's stdout/stderr there
        log_fh = open(LOG_FILE, "a", buffering=1, encoding="utf-8", errors="replace")

        # Platform-specific detachment
        kwargs = {}
        if os.name == "nt":
            # Fully detach on Windows
            kwargs["creationflags"] = subprocess.DETACHED_PROCESS | subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW        # On Windows, close_fds cannot be True when redirecting std handles on py<3.12; omit it.
        else:
            # Detach from controlling terminal/session on POSIX
            kwargs["preexec_fn"] = os.setpgrp
            kwargs["close_fds"] = True

        proc = subprocess.Popen(
            cmd,
            stdout=log_fh,
            stderr=log_fh,
            stdin=subprocess.DEVNULL,
            cwd=str(SRC_DIR),
            **kwargs
        )
        # Write the PID so we can stop later
        PID_FILE.write_text(str(proc.pid), encoding="utf-8")
        logger.info(f"{get_icon('check')} Server started (detached) on http://{host}:{port}")
        logger.info(f"{get_icon('info')}    PID: {proc.pid}")
        logger.info(f"{get_icon('info')}    Log: {LOG_FILE}")


def stop_server():
    """
    Stop a previously started detached server using the PID file.
    """
    if not PID_FILE.exists():
        logger.error(f"{get_icon('stop')} No PID file found; server may not be running.")
        return

    try:
        pid = int(PID_FILE.read_text(encoding="utf-8").strip() or "0")
    except ValueError:
        logger.error(f"{get_icon('stop')} No PID file found; server may not be running.")
        return

    if pid <= 0:
        logger.error(f"{get_icon('stop')} No PID file found; server may not be running.")
        return

    # Try to terminate cross-platform
    try:
        if os.name == "nt":
            # Use taskkill to terminate the process tree reliably on Windows
            subprocess.run(["taskkill", "/PID", str(pid), "/T", "/F"],
                           capture_output=True, text=True)
        else:
            os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        logger.error(f"{get_icon('stop')} Process {pid} not found.")
    except Exception as e:
        logger.error(f"{get_icon('stop')} Error stopping process {pid}\n: {e}")
    else:
        logger.info(f"{get_icon('info')} Sent stop signal to PID {pid}")

    # Clean up PID file regardless (best-effort)
    try:
        PID_FILE.unlink(missing_ok=True)
    except Exception:
        pass



def port_type(value: str) -> int:
    """Custom argparse type that validates a TCP port number."""
    try:
        port = int(value)
    except ValueError:
        logger.error(f"{get_icon('cross')} Port must be an integer (got {value!r})")
        raise argparse.ArgumentTypeError(f"Port must be an integer (got {value!r})")
    
    if not (1 <= port <= 65535):
        logger.error(f"{get_icon('cross')} Port number must be between 1 and 65535 (got {port!r})")
        raise argparse.ArgumentTypeError(f"Port number must be between 1 and 65535 (got {port!r})")
    
    return port

def main():
    parser = argparse.ArgumentParser(
        description="Create and run an MCP server or client."
    )
    parser.add_argument("--mode",
        choices=["server", "client", "stop-server"],
        type=str.lower,
        required=True,
        help="Run as server, client, or stop-server."
    )
    parser.add_argument("--host", type=str, default="127.0.0.1",
                        help="Host name or IP address (default 127.0.0.1).")
    parser.add_argument("--port", type=port_type, default=8085,
                        help="TCP port to bind/connect (default 8085).")
    parser.add_argument("--debug", type=bool, default=False,
                        help="Lauch the server as a child of this Process (True) or as a seperate Process (False).\n The default is False")
    args = parser.parse_args()

    if args.mode == "server":
        # Parent: launch a detached child and return immediately
        start_server(args.host, args.port, args.debug)
        # Parent exits now; detached child continues running.

    elif args.mode == "stop-server":
        stop_server()

    elif args.mode == "client":
        client = universal_client(args.host, args.port)
        asyncio.run(client.run())


if __name__ == "__main__":
    main()
